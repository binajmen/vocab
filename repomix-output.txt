This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-22T15:44:19.839Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
backend/
  priv/
    layouts/
      expression.json
      short_verb.json
      verb.json
    migrations/
      20250221114514-init.sql
      20250221122942-create_users.sql
  src/
    app/
      cards/
        router.gleam
      users/
        sql/
          create_user.sql
          find_user.sql
          find_users.sql
        router.gleam
        sql.gleam
      context.gleam
      router.gleam
      web.gleam
    layout/
      expression.gleam
      grammar.gleam
      verb.gleam
    app.gleam
  test/
    app_test.gleam
  .gitignore
  Dockerfile
  gleam.toml
  manifest.toml
  README.md
  sql.schema
frontend/
  src/
    core/
      users/
        users.api.ts
        users.schema.ts
    routes/
      console/
        users/
          $user_id.tsx
          create.tsx
          index.tsx
        users.tsx
      __root.tsx
      about.tsx
      hello.tsx
      index.tsx
    utils/
      valibot.ts
    api.ts
    main.tsx
    routeTree.gen.ts
  .dockerignore
  .gitignore
  Dockerfile
  index.html
  package.json
  README.md
  tsconfig.json
  vite.config.ts
biome.json
compose.yml

================================================================
Repository Files
================================================================

================
File: backend/priv/layouts/expression.json
================
{
  "id": "expression",
  "name": "Expression"
}

================
File: backend/priv/layouts/short_verb.json
================
{
  "id": "short_verb",
  "name": "Short verb",
  "tabs": [
    {
      "fields": [{ "label": "Present" }, { "label": "Participle" }]
    }
  ]
}

================
File: backend/priv/layouts/verb.json
================
{
  "id": "verb",
  "name": "Verb",
  "tabs": [
    {
      "name": "Present",
      "fields": ["ich", "du", "er/sie/es", "wir", "ihr", "Sie/sie"]
    },
    {
      "name": "Past",
      "fields": ["ich", "du", "er/sie/es", "wir", "ihr", "Sie/sie"]
    },
    {
      "name": "Participle"
    }
  ]
}

================
File: backend/priv/migrations/20250221114514-init.sql
================
--- migration:up
create extension if not exists "uuid-ossp";

--- migration:down
drop extension if exists "uuid-ossp";

--- migration:end

================
File: backend/priv/migrations/20250221122942-create_users.sql
================
--- migration:up
create table users (
  id uuid primary key default gen_random_uuid (),
  email varchar(255) not null unique
);

--- migration:down
drop table if exists users;

--- migration:end

================
File: backend/src/app/cards/router.gleam
================
import app/context.{type Context}
import wisp.{type Request, type Response}

pub fn random(req: Request, _ctx: Context) -> Response {
  todo
}

================
File: backend/src/app/users/sql/create_user.sql
================
insert into
  users (id, email)
values
  ($1, $2)
returning
  id,
  email

================
File: backend/src/app/users/sql/find_user.sql
================
select
  *
from
  users
where
  users.id = $1

================
File: backend/src/app/users/sql/find_users.sql
================
select
  *
from
  users;

================
File: backend/src/app/users/router.gleam
================
import app/context.{type Context}
import app/users/sql
import gleam/dynamic/decode
import gleam/json
import gleam/result
import pog
import wisp.{type Request, type Response}
import youid/uuid

pub fn list_users(_req: Request, ctx: Context) -> Response {
  let result = {
    use pog.Returned(_, rows) <- result.try(sql.find_users(ctx.db))

    Ok(
      json.array(rows, fn(user) {
        json.object([
          #("id", json.string(uuid.to_string(user.id))),
          #("email", json.string(user.email)),
        ])
      }),
    )
  }

  case result {
    Ok(json) -> json.to_string_tree(json) |> wisp.json_response(200)
    Error(_) -> wisp.internal_server_error()
  }
}

pub fn find_user(_req: Request, ctx: Context, user_id: String) -> Response {
  let assert Ok(user_id) = uuid.from_string(user_id)

  let result = {
    use pog.Returned(_, rows) <- result.try(sql.find_user(ctx.db, user_id))
    Ok(rows)
  }

  let user = case result {
    Ok([row]) ->
      Ok(
        json.object([
          #("id", json.string(uuid.to_string(row.id))),
          #("email", json.string(row.email)),
        ]),
      )
    Ok(_) -> Error("unique user not found")
    Error(_) -> Error("query error")
  }

  case user {
    Ok(user) -> json.to_string_tree(user) |> wisp.json_response(200)
    Error(_) -> wisp.internal_server_error()
  }
}

pub fn create_user(req: Request, ctx: Context) -> Response {
  use json <- wisp.require_json(req)

  let decode_payload = {
    use email <- decode.field("email", decode.string)
    decode.success(email)
  }

  case decode.run(json, decode_payload) {
    Ok(email) -> {
      case sql.create_user(ctx.db, uuid.v7(), email) {
        Ok(pog.Returned(_, [row])) ->
          json.object([
            #("id", json.string(uuid.to_string(row.id))),
            #("email", json.string(row.email)),
          ])
          |> json.to_string_tree()
          |> wisp.json_response(200)
        Ok(pog.Returned(_, [])) -> wisp.unprocessable_entity()
        Ok(pog.Returned(_, [_, _, ..])) -> wisp.unprocessable_entity()
        Error(_) -> wisp.unprocessable_entity()
      }
    }
    Error(_) -> wisp.unprocessable_entity()
  }
}

================
File: backend/src/app/users/sql.gleam
================
import gleam/dynamic/decode
import pog
import youid/uuid.{type Uuid}

/// A row you get from running the `find_users` query
/// defined in `./src/app/users/sql/find_users.sql`.
///
/// > ðŸ¿ï¸ This type definition was generated automatically using v3.0.1 of the
/// > [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub type FindUsersRow {
  FindUsersRow(id: Uuid, email: String)
}

/// Runs the `find_users` query
/// defined in `./src/app/users/sql/find_users.sql`.
///
/// > ðŸ¿ï¸ This function was generated automatically using v3.0.1 of
/// > the [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub fn find_users(db) {
  let decoder = {
    use id <- decode.field(0, uuid_decoder())
    use email <- decode.field(1, decode.string)
    decode.success(FindUsersRow(id:, email:))
  }

  "select
  *
from
  users;
"
  |> pog.query
  |> pog.returning(decoder)
  |> pog.execute(db)
}

/// A row you get from running the `create_user` query
/// defined in `./src/app/users/sql/create_user.sql`.
///
/// > ðŸ¿ï¸ This type definition was generated automatically using v3.0.1 of the
/// > [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub type CreateUserRow {
  CreateUserRow(id: Uuid, email: String)
}

/// Runs the `create_user` query
/// defined in `./src/app/users/sql/create_user.sql`.
///
/// > ðŸ¿ï¸ This function was generated automatically using v3.0.1 of
/// > the [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub fn create_user(db, arg_1, arg_2) {
  let decoder = {
    use id <- decode.field(0, uuid_decoder())
    use email <- decode.field(1, decode.string)
    decode.success(CreateUserRow(id:, email:))
  }

  "insert into
  users (id, email)
values
  ($1, $2)
returning
  id,
  email
"
  |> pog.query
  |> pog.parameter(pog.text(uuid.to_string(arg_1)))
  |> pog.parameter(pog.text(arg_2))
  |> pog.returning(decoder)
  |> pog.execute(db)
}

/// A row you get from running the `find_user` query
/// defined in `./src/app/users/sql/find_user.sql`.
///
/// > ðŸ¿ï¸ This type definition was generated automatically using v3.0.1 of the
/// > [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub type FindUserRow {
  FindUserRow(id: Uuid, email: String)
}

/// Runs the `find_user` query
/// defined in `./src/app/users/sql/find_user.sql`.
///
/// > ðŸ¿ï¸ This function was generated automatically using v3.0.1 of
/// > the [squirrel package](https://github.com/giacomocavalieri/squirrel).
///
pub fn find_user(db, arg_1) {
  let decoder = {
    use id <- decode.field(0, uuid_decoder())
    use email <- decode.field(1, decode.string)
    decode.success(FindUserRow(id:, email:))
  }

  "select
  *
from
  users
where
  users.id = $1
"
  |> pog.query
  |> pog.parameter(pog.text(uuid.to_string(arg_1)))
  |> pog.returning(decoder)
  |> pog.execute(db)
}

// --- Encoding/decoding utils -------------------------------------------------

/// A decoder to decode `Uuid`s coming from a Postgres query.
///
fn uuid_decoder() {
  use bit_array <- decode.then(decode.bit_array)
  case uuid.from_bit_array(bit_array) {
    Ok(uuid) -> decode.success(uuid)
    Error(_) -> decode.failure(uuid.v7(), "uuid")
  }
}

================
File: backend/src/app/context.gleam
================
import envoy
import gleam/result
import pog

pub type Context {
  Context(db: pog.Connection)
}

pub fn init() -> Result(Context, String) {
  let assert Ok(db) = init_database()
  Ok(Context(db))
}

fn init_database() {
  use database_url <- result.try(envoy.get("DATABASE_URL"))
  use config <- result.try(pog.url_config(database_url))
  Ok(pog.connect(config))
}

================
File: backend/src/app/router.gleam
================
import app/cards/router as card
import app/context.{type Context}
import app/users/router as user
import app/web
import cors_builder
import gleam/http.{Get, Post}
import wisp.{type Request, type Response}

pub fn handle_get(req: Request, ctx: Context) {
  case wisp.path_segments(req) {
    ["healthcheck"] -> wisp.ok()
    ["users"] -> user.list_users(req, ctx)
    ["users", user_id] -> user.find_user(req, ctx, user_id)
    ["random"] -> card.random(req, ctx)
    _ -> wisp.not_found()
  }
}

pub fn handle_post(req: Request, ctx: Context) {
  case wisp.path_segments(req) {
    ["users"] -> user.create_user(req, ctx)
    _ -> wisp.not_found()
  }
}

pub fn handle_request(req: Request, ctx: Context) -> Response {
  use req <- cors_builder.wisp_middleware(req, web.cors())
  use req <- web.middleware(req)
  case req.method {
    http.Get -> handle_get(req, ctx)
    http.Post -> handle_post(req, ctx)
    _ -> wisp.not_found()
  }
}

================
File: backend/src/app/web.gleam
================
import cors_builder
import gleam/http
import wisp

pub fn cors() {
  cors_builder.new()
  |> cors_builder.allow_origin("*")
  |> cors_builder.allow_method(http.Get)
  |> cors_builder.allow_method(http.Post)
  |> cors_builder.allow_method(http.Put)
  |> cors_builder.allow_method(http.Patch)
  |> cors_builder.allow_header("content-type")
}

pub fn middleware(
  req: wisp.Request,
  handle_request: fn(wisp.Request) -> wisp.Response,
) -> wisp.Response {
  let req = wisp.method_override(req)
  use <- wisp.log_request(req)
  use <- wisp.rescue_crashes
  use req <- wisp.handle_head(req)

  handle_request(req)
}

================
File: backend/src/layout/expression.gleam
================
import gleam/option.{None}
import layout/grammar.{type Lexicon, Lexicon}

pub type Expression {
  Expression(id: String, name: String)
}

pub fn to_expression(lexicon: Lexicon) -> Result(Expression, String) {
  case lexicon {
    Lexicon(id, name, None) -> Ok(Expression(id, name))
    _ -> Error("invalid expression format")
  }
}

================
File: backend/src/layout/grammar.gleam
================
import gleam/dynamic/decode
import gleam/option.{type Option}

pub type Lexicon {
  Lexicon(id: String, name: String, tabs: Option(List(Tab)))
}

pub fn lexicon_decoder() {
  use id <- decode.field("id", decode.string)
  use name <- decode.field("name", decode.string)
  use tabs <- decode.field("tabs", decode.optional(decode.list(tab_decoder())))
  decode.success(Lexicon(id, name, tabs))
}

pub type Tab {
  Tab(name: Option(String), fields: List(Field))
}

fn tab_decoder() {
  use name <- decode.field("name", decode.optional(decode.string))
  use fields <- decode.optional_field(
    "fields",
    [],
    decode.list(field_decoder()),
  )
  decode.success(Tab(name, fields))
}

pub type Field =
  String

fn field_decoder() {
  decode.string
}

================
File: backend/src/layout/verb.gleam
================
import gleam/option.{Some}
import layout/grammar.{type Lexicon, type Tab, Lexicon}

pub type Verb {
  Verb(id: String, name: String, tabs: List(Tab))
}

pub fn to_verb(lexicon: Lexicon) -> Result(Verb, String) {
  case lexicon {
    Lexicon(id, name, Some(tabs)) -> Ok(Verb(id, name, tabs))
    _ -> Error("invalid verb format")
  }
}

================
File: backend/src/app.gleam
================
import app/context
import app/router
import gleam/erlang/process
import mist
import wisp
import wisp/wisp_mist

pub fn main() {
  wisp.configure_logger()
  let assert Ok(ctx) = context.init()
  let assert Ok(_) = start_http_server(ctx)
  process.sleep_forever()
}

fn start_http_server(ctx) {
  let secret_key_base = wisp.random_string(64)

  router.handle_request(_, ctx)
  |> wisp_mist.handler(secret_key_base)
  |> mist.new()
  |> mist.port(8000)
  |> mist.start_http
}

================
File: backend/test/app_test.gleam
================
import gleeunit
import gleeunit/should

pub fn main() {
  gleeunit.main()
}

// gleeunit test functions end in `_test`
pub fn hello_world_test() {
  1
  |> should.equal(1)
}

================
File: backend/.gitignore
================
build

================
File: backend/Dockerfile
================
FROM ghcr.io/gleam-lang/gleam:v1.8.1-erlang

# Add project code
COPY . /build/

# Compile the project
RUN cd /build \
	&& gleam export erlang-shipment \
	&& mv build/erlang-shipment /app \
	&& rm -r /build

# Run the server
WORKDIR /app
ENTRYPOINT ["/app/entrypoint.sh"]
CMD ["run"]

================
File: backend/gleam.toml
================
name = "app"
version = "1.0.0"

# Fill out these fields if you intend to generate HTML documentation or publish
# your project to the Hex package manager.
#
# description = ""
# licences = ["Apache-2.0"]
# repository = { type = "github", user = "", repo = "" }
# links = [{ title = "Website", href = "" }]
#
# For a full reference of all the available options, you can have a look at
# https://gleam.run/writing-gleam/gleam-toml/.

[dependencies]
gleam_stdlib = ">= 0.44.0 and < 2.0.0"
gleam_json = ">= 2.3.0 and < 3.0.0"
wisp = ">= 1.5.3 and < 2.0.0"
mist = ">= 4.0.6 and < 5.0.0"
gleam_erlang = ">= 0.34.0 and < 1.0.0"
pog = ">= 3.2.0 and < 4.0.0"
glanoid = ">= 1.0.1 and < 2.0.0"
youid = ">= 1.2.0 and < 2.0.0"
envoy = ">= 1.0.2 and < 2.0.0"
gleam_http = ">= 3.7.2 and < 4.0.0"
cors_builder = ">= 2.0.3 and < 3.0.0"

[dev-dependencies]
gleeunit = ">= 1.0.0 and < 2.0.0"
cigogne = ">= 2.0.2 and < 3.0.0"
squirrel = ">= 3.0.1 and < 4.0.0"

================
File: backend/manifest.toml
================
# This file was generated by Gleam
# You typically do not need to edit this file

packages = [
  { name = "argv", version = "1.0.2", build_tools = ["gleam"], requirements = [], otp_app = "argv", source = "hex", outer_checksum = "BA1FF0929525DEBA1CE67256E5ADF77A7CDDFE729E3E3F57A5BDCAA031DED09D" },
  { name = "backoff", version = "1.1.6", build_tools = ["rebar3"], requirements = [], otp_app = "backoff", source = "hex", outer_checksum = "CF0CFFF8995FB20562F822E5CC47D8CCF664C5ECDC26A684CBE85C225F9D7C39" },
  { name = "cigogne", version = "2.0.2", build_tools = ["gleam"], requirements = ["argv", "envoy", "gleam_stdlib", "globlin", "globlin_fs", "gtempo", "pog", "shellout", "simplifile"], otp_app = "cigogne", source = "hex", outer_checksum = "54497DFC4A6C7FB200DA80D841D1113EE2470DBA56EF2E78EC53F9843A0D2707" },
  { name = "cors_builder", version = "2.0.3", build_tools = ["gleam"], requirements = ["gleam_http", "gleam_stdlib", "mist", "wisp"], otp_app = "cors_builder", source = "hex", outer_checksum = "F9D52C82913AA2A73E3B3785DAD56CCBFE99588273DBCC6C4E25F374EB8D267A" },
  { name = "directories", version = "1.1.0", build_tools = ["gleam"], requirements = ["envoy", "gleam_stdlib", "platform", "simplifile"], otp_app = "directories", source = "hex", outer_checksum = "BDA521A4EB9EE3A7894F0DC863797878E91FF5C7826F7084B2E731E208BDB076" },
  { name = "envoy", version = "1.0.2", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "envoy", source = "hex", outer_checksum = "95FD059345AA982E89A0B6E2A3BF1CF43E17A7048DCD85B5B65D3B9E4E39D359" },
  { name = "eval", version = "1.0.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "eval", source = "hex", outer_checksum = "264DAF4B49DF807F303CA4A4E4EBC012070429E40BE384C58FE094C4958F9BDA" },
  { name = "exception", version = "2.0.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "exception", source = "hex", outer_checksum = "F5580D584F16A20B7FCDCABF9E9BE9A2C1F6AC4F9176FA6DD0B63E3B20D450AA" },
  { name = "filepath", version = "1.1.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "filepath", source = "hex", outer_checksum = "67A6D15FB39EEB69DD31F8C145BB5A421790581BD6AA14B33D64D5A55DBD6587" },
  { name = "glam", version = "2.0.2", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "glam", source = "hex", outer_checksum = "4932A2D139AB0389E149396407F89654928D7B815E212BB02F13C66F53B1BBA1" },
  { name = "glanoid", version = "1.0.1", build_tools = ["gleam"], requirements = ["gleam_crypto", "gleam_stdlib"], otp_app = "glanoid", source = "hex", outer_checksum = "234440F3ED19BD65D166D31CA107991B14C6104AABFC0B75E3581358DCC7D0F3" },
  { name = "gleam_community_ansi", version = "1.4.2", build_tools = ["gleam"], requirements = ["gleam_community_colour", "gleam_regexp", "gleam_stdlib"], otp_app = "gleam_community_ansi", source = "hex", outer_checksum = "479DEDC748D08B310C9FEB9C4CBEC46B95C874F7F4F2844304D6D20CA78A8BB5" },
  { name = "gleam_community_colour", version = "1.4.1", build_tools = ["gleam"], requirements = ["gleam_json", "gleam_stdlib"], otp_app = "gleam_community_colour", source = "hex", outer_checksum = "386CB9B01B33371538672EEA8A6375A0A0ADEF41F17C86DDCB81C92AD00DA610" },
  { name = "gleam_crypto", version = "1.4.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_crypto", source = "hex", outer_checksum = "8AE56026B3E05EBB1F076778478A762E9EB62B31AEEB4285755452F397029D22" },
  { name = "gleam_erlang", version = "0.34.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_erlang", source = "hex", outer_checksum = "0C38F2A128BAA0CEF17C3000BD2097EB80634E239CE31A86400C4416A5D0FDCC" },
  { name = "gleam_http", version = "3.7.2", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_http", source = "hex", outer_checksum = "8A70D2F70BB7CFEB5DF048A2183FFBA91AF6D4CF5798504841744A16999E33D2" },
  { name = "gleam_json", version = "2.3.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_json", source = "hex", outer_checksum = "C55C5C2B318533A8072D221C5E06E5A75711C129E420DD1CE463342106012E5D" },
  { name = "gleam_otp", version = "0.16.1", build_tools = ["gleam"], requirements = ["gleam_erlang", "gleam_stdlib"], otp_app = "gleam_otp", source = "hex", outer_checksum = "50DA1539FC8E8FA09924EB36A67A2BBB0AD6B27BCDED5A7EF627057CF69D035E" },
  { name = "gleam_regexp", version = "1.1.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_regexp", source = "hex", outer_checksum = "7F5E0C0BBEB3C58E57C9CB05FA9002F970C85AD4A63BA1E55CBCB35C15809179" },
  { name = "gleam_stdlib", version = "0.54.0", build_tools = ["gleam"], requirements = [], otp_app = "gleam_stdlib", source = "hex", outer_checksum = "723BA61A2BAE8D67406E59DD88CEA1B3C3F266FC8D70F64BE9FEC81B4505B927" },
  { name = "gleam_yielder", version = "1.1.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleam_yielder", source = "hex", outer_checksum = "8E4E4ECFA7982859F430C57F549200C7749823C106759F4A19A78AEA6687717A" },
  { name = "gleeunit", version = "1.3.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "gleeunit", source = "hex", outer_checksum = "0E6C83834BA65EDCAAF4FE4FB94AC697D9262D83E6F58A750D63C9F6C8A9D9FF" },
  { name = "glexer", version = "2.1.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "glexer", source = "hex", outer_checksum = "F74FB4F78C3C1E158DF15A7226F33A662672F58EEF1DFE6593B7FCDA38B0A0EB" },
  { name = "glisten", version = "7.0.1", build_tools = ["gleam"], requirements = ["gleam_erlang", "gleam_otp", "gleam_stdlib", "logging", "telemetry"], otp_app = "glisten", source = "hex", outer_checksum = "1A53CF9FB3231A93FF7F1BD519A43DC968C1722F126CDD278403A78725FC5189" },
  { name = "globlin", version = "2.0.3", build_tools = ["gleam"], requirements = ["gleam_regexp", "gleam_stdlib"], otp_app = "globlin", source = "hex", outer_checksum = "923BC16814DF95C4BB28111C266F0B873499480E6E125D5A16DBDF732E62CEB4" },
  { name = "globlin_fs", version = "2.0.0", build_tools = ["gleam"], requirements = ["filepath", "gleam_stdlib", "globlin", "simplifile"], otp_app = "globlin_fs", source = "hex", outer_checksum = "2A84CE81FD7958B967EF39CC234AFB64DAB20169D0EF9B9C3943CD3C5B561182" },
  { name = "gramps", version = "3.0.0", build_tools = ["gleam"], requirements = ["gleam_crypto", "gleam_erlang", "gleam_http", "gleam_stdlib"], otp_app = "gramps", source = "hex", outer_checksum = "630BDE35E465511945253A06EBCDE8D5E4B8B1988F4AC6B8FAC297DEF55B4CA2" },
  { name = "gtempo", version = "5.1.2", build_tools = ["gleam"], requirements = ["gleam_regexp", "gleam_stdlib", "gleam_yielder"], otp_app = "gtempo", source = "hex", outer_checksum = "61D128B30C7C165A7E08108465791AD2D85B181EC35C0289638F8CB94E28FCF9" },
  { name = "hpack_erl", version = "0.3.0", build_tools = ["rebar3"], requirements = [], otp_app = "hpack", source = "hex", outer_checksum = "D6137D7079169D8C485C6962DFE261AF5B9EF60FBC557344511C1E65E3D95FB0" },
  { name = "justin", version = "1.0.1", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "justin", source = "hex", outer_checksum = "7FA0C6DB78640C6DC5FBFD59BF3456009F3F8B485BF6825E97E1EB44E9A1E2CD" },
  { name = "logging", version = "1.3.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "logging", source = "hex", outer_checksum = "1098FBF10B54B44C2C7FDF0B01C1253CAFACDACABEFB4B0D027803246753E06D" },
  { name = "marceau", version = "1.3.0", build_tools = ["gleam"], requirements = [], otp_app = "marceau", source = "hex", outer_checksum = "2D1C27504BEF45005F5DFB18591F8610FB4BFA91744878210BDC464412EC44E9" },
  { name = "mist", version = "4.0.6", build_tools = ["gleam"], requirements = ["gleam_erlang", "gleam_http", "gleam_otp", "gleam_stdlib", "gleam_yielder", "glisten", "gramps", "hpack_erl", "logging"], otp_app = "mist", source = "hex", outer_checksum = "ED319E5A7F2056E08340B6976EA5E717F3C3BB36056219AF826D280D9C077952" },
  { name = "mug", version = "1.2.0", build_tools = ["gleam"], requirements = ["gleam_erlang", "gleam_stdlib"], otp_app = "mug", source = "hex", outer_checksum = "C5F62A3FD753B823CE296ED1B223D4B2FF06E91170A7DE35A283D70BB74B700E" },
  { name = "non_empty_list", version = "2.1.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "non_empty_list", source = "hex", outer_checksum = "3BF1496B475F3F2CE2EA18157587329812493369B2A7C5B9DCFEA5C007670A3B" },
  { name = "opentelemetry_api", version = "1.4.0", build_tools = ["rebar3", "mix"], requirements = [], otp_app = "opentelemetry_api", source = "hex", outer_checksum = "3DFBBFAA2C2ED3121C5C483162836C4F9027DEF469C41578AF5EF32589FCFC58" },
  { name = "pg_types", version = "0.4.0", build_tools = ["rebar3"], requirements = [], otp_app = "pg_types", source = "hex", outer_checksum = "B02EFA785CAECECF9702C681C80A9CA12A39F9161A846CE17B01FB20AEEED7EB" },
  { name = "pgo", version = "0.14.0", build_tools = ["rebar3"], requirements = ["backoff", "opentelemetry_api", "pg_types"], otp_app = "pgo", source = "hex", outer_checksum = "71016C22599936E042DC0012EE4589D24C71427D266292F775EBF201D97DF9C9" },
  { name = "platform", version = "1.0.0", build_tools = ["gleam"], requirements = [], otp_app = "platform", source = "hex", outer_checksum = "8339420A95AD89AAC0F82F4C3DB8DD401041742D6C3F46132A8739F6AEB75391" },
  { name = "pog", version = "3.2.0", build_tools = ["gleam"], requirements = ["gleam_stdlib", "pgo"], otp_app = "pog", source = "hex", outer_checksum = "63152DADEBAE3150C81E9612909974C3C38F3E35B41F252798069A2FD117308E" },
  { name = "shellout", version = "1.6.0", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "shellout", source = "hex", outer_checksum = "E2FCD18957F0E9F67E1F497FC9FF57393392F8A9BAEAEA4779541DE7A68DD7E0" },
  { name = "simplifile", version = "2.2.0", build_tools = ["gleam"], requirements = ["filepath", "gleam_stdlib"], otp_app = "simplifile", source = "hex", outer_checksum = "0DFABEF7DC7A9E2FF4BB27B108034E60C81BEBFCB7AB816B9E7E18ED4503ACD8" },
  { name = "squirrel", version = "3.0.1", build_tools = ["gleam"], requirements = ["argv", "envoy", "eval", "filepath", "glam", "gleam_community_ansi", "gleam_crypto", "gleam_json", "gleam_regexp", "gleam_stdlib", "glexer", "justin", "mug", "non_empty_list", "pog", "simplifile", "term_size", "tom", "tote", "youid"], otp_app = "squirrel", source = "hex", outer_checksum = "B0059A5C86E57D055B64F7591366117E2CF5EBD686BBA9470A1387D81A517DCB" },
  { name = "telemetry", version = "1.3.0", build_tools = ["rebar3"], requirements = [], otp_app = "telemetry", source = "hex", outer_checksum = "7015FC8919DBE63764F4B4B87A95B7C0996BD539E0D499BE6EC9D7F3875B79E6" },
  { name = "term_size", version = "1.0.1", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "term_size", source = "hex", outer_checksum = "D00BD2BC8FB3EBB7E6AE076F3F1FF2AC9D5ED1805F004D0896C784D06C6645F1" },
  { name = "tom", version = "1.1.1", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "tom", source = "hex", outer_checksum = "0910EE688A713994515ACAF1F486A4F05752E585B9E3209D8F35A85B234C2719" },
  { name = "tote", version = "1.0.2", build_tools = ["gleam"], requirements = ["gleam_stdlib"], otp_app = "tote", source = "hex", outer_checksum = "A249892E26A53C668897F8D47845B0007EEE07707A1A03437487F0CD5A452CA5" },
  { name = "wisp", version = "1.5.3", build_tools = ["gleam"], requirements = ["directories", "exception", "gleam_crypto", "gleam_erlang", "gleam_http", "gleam_json", "gleam_stdlib", "logging", "marceau", "mist", "simplifile"], otp_app = "wisp", source = "hex", outer_checksum = "DCD083E0ED3D30EA8CF2EECCA01A8108F7987D7BD908F527862E3D2725436444" },
  { name = "youid", version = "1.2.0", build_tools = ["gleam"], requirements = ["gleam_crypto", "gleam_erlang", "gleam_stdlib"], otp_app = "youid", source = "hex", outer_checksum = "EF0F693004E221155EE5909C6D3C945DD14F7117DBA882887CF5F45BE399B8CA" },
]

[requirements]
cigogne = { version = ">= 2.0.2 and < 3.0.0" }
cors_builder = { version = ">= 2.0.3 and < 3.0.0" }
envoy = { version = ">= 1.0.2 and < 2.0.0" }
glanoid = { version = ">= 1.0.1 and < 2.0.0" }
gleam_erlang = { version = ">= 0.34.0 and < 1.0.0" }
gleam_http = { version = ">= 3.7.2 and < 4.0.0" }
gleam_json = { version = ">= 2.3.0 and < 3.0.0" }
gleam_stdlib = { version = ">= 0.44.0 and < 2.0.0" }
gleeunit = { version = ">= 1.0.0 and < 2.0.0" }
mist = { version = ">= 4.0.6 and < 5.0.0" }
pog = { version = ">= 3.2.0 and < 4.0.0" }
squirrel = { version = ">= 3.0.1 and < 4.0.0" }
wisp = { version = ">= 1.5.3 and < 2.0.0" }
youid = { version = ">= 1.2.0 and < 2.0.0" }

================
File: backend/README.md
================
# app

[![Package Version](https://img.shields.io/hexpm/v/app)](https://hex.pm/packages/app)
[![Hex Docs](https://img.shields.io/badge/hex-docs-ffaff3)](https://hexdocs.pm/app/)

```sh
gleam add app@1
```
```gleam
import app

pub fn main() {
  // TODO: An example of the project in use
}
```

Further documentation can be found at <https://hexdocs.pm/app>.

## Development

```sh
gleam run   # Run the project
gleam test  # Run the tests
```

================
File: backend/sql.schema
================
Table "public._migrations"
  Column   |            Type             | Collation | Nullable |                 Default                 
-----------+-----------------------------+-----------+----------+-----------------------------------------
 id        | integer                     |           | not null | nextval('_migrations_id_seq'::regclass)
 name      | character varying(255)      |           | not null | 
 createdat | timestamp without time zone |           | not null | 
 appliedat | timestamp without time zone |           | not null | now()
Indexes:
    "_migrations_pkey" PRIMARY KEY, btree (id)

                 Sequence "public._migrations_id_seq"
  Type   | Start | Minimum |  Maximum   | Increment | Cycles? | Cache 
---------+-------+---------+------------+-----------+---------+-------
 integer |     1 |       1 | 2147483647 |         1 | no      |     1
Owned by: public._migrations.id

   Index "public._migrations_pkey"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 id     | integer | yes  | id
primary key, btree, for table "public._migrations"

                            Table "public.users"
 Column |          Type          | Collation | Nullable |      Default      
--------+------------------------+-----------+----------+-------------------
 id     | uuid                   |           | not null | gen_random_uuid()
 email  | character varying(255) |           | not null | 
Indexes:
    "users_pkey" PRIMARY KEY, btree (id)
    "users_email_key" UNIQUE CONSTRAINT, btree (email)

           Index "public.users_email_key"
 Column |          Type          | Key? | Definition 
--------+------------------------+------+------------
 email  | character varying(255) | yes  | email
unique, btree, for table "public.users"

     Index "public.users_pkey"
 Column | Type | Key? | Definition 
--------+------+------+------------
 id     | uuid | yes  | id
primary key, btree, for table "public.users"

================
File: frontend/src/core/users/users.api.ts
================
import { type MutationOptions, queryOptions } from "@tanstack/solid-query";
import { get, post } from "~/api";
import { v } from "~/utils/valibot";
import { type User, UserSchema } from "./users.schema";

const list = queryOptions({
  queryKey: ["users"],
  queryFn: () => get("/users", v.array(UserSchema)),
});

const find = (user_id: string) =>
  queryOptions({
    queryKey: ["users", user_id],
    queryFn: () => get(`/users/${user_id}`, UserSchema),
  });

const create = {
  mutationFn: (values) => post("/users", values, UserSchema),
} satisfies MutationOptions<User, Error, { email: string }>;

export const users = {
  list,
  find,
  create,
};

================
File: frontend/src/core/users/users.schema.ts
================
import { v } from "~/utils/valibot";

export const UserSchema = v.object({
  id: v.string(),
  email: v.pipe(v.string(), v.email()),
});

export type User = v.InferOutput<typeof UserSchema>;

export const CreateUserSchema = v.object({
  email: v.pipe(v.string(), v.email()),
});

================
File: frontend/src/routes/console/users/$user_id.tsx
================
import { createFileRoute } from "@tanstack/solid-router";

export const Route = createFileRoute("/console/users/$user_id")({
  component: RouteComponent,
  loader: ({ context: { api, query }, params }) =>
    query.ensureQueryData(api.users.find(params.user_id)),
});

function RouteComponent() {
  const user = Route.useLoaderData();

  return (
    <div>
      Hello "/console/users/$user_id"!
      <pre>{JSON.stringify(user(), null, 2)}</pre>
    </div>
  );
}

================
File: frontend/src/routes/console/users/create.tsx
================
import { createForm } from "@tanstack/solid-form";
import { createFileRoute, useNavigate } from "@tanstack/solid-router";
import { CreateUserSchema } from "~/core/users/users.schema";
import { api } from "~/api";
import { createMutation } from "@tanstack/solid-query";

export const Route = createFileRoute("/console/users/create")({
  component: RouteComponent,
});

function RouteComponent() {
  const navigate = useNavigate();
  const create = createMutation(() => ({
    ...api.users.create,
    onSuccess: (data) =>
      navigate({ to: "/console/users/$user_id", params: { user_id: data.id } }),
  }));
  const form = createForm(() => ({
    defaultValues: {
      email: "",
    },
    validators: { onBlur: CreateUserSchema },
    onSubmit: ({ value }) => {
      create.mutate(value);
    },
  }));

  return (
    <div>
      <form
        onSubmit={(e) => {
          e.preventDefault();
          e.stopPropagation();
          form.handleSubmit();
        }}
      >
        <form.Field
          name="email"
          children={(field) => (
            <>
              <input
                name={field().name}
                value={field().state.value}
                onBlur={field().handleBlur}
                onInput={(e) => field().handleChange(e.target.value)}
              />
              <p>{field().state.meta.errors.map((e) => e?.message)}</p>
            </>
          )}
        />
        <form.Subscribe
          // selector={(state) => ({ canSubmit: state.canSubmit,  })}
          children={(state) => (
            <button
              type="submit"
              disabled={!state().canSubmit || state().isPristine}
            >
              Submit
            </button>
          )}
        />
      </form>
    </div>
  );
}

================
File: frontend/src/routes/console/users/index.tsx
================
import { createFileRoute, Link } from "@tanstack/solid-router";
import { For } from "solid-js";

export const Route = createFileRoute("/console/users/")({
  component: ConsoleUsersList,
  loader: ({ context: { api, query } }) =>
    query.ensureQueryData(api.users.list),
});

function ConsoleUsersList() {
  const users = Route.useLoaderData();

  return (
    <div class="p-2">
      Hello from /console/users/index!
      <For each={users()}>
        {(user) => (
          <div>
            {user.id} {user.email}{" "}
            <Link
              to="/console/users/$user_id"
              params={{ user_id: user.id }}
              preload="intent"
            >
              View
            </Link>
          </div>
        )}
      </For>
    </div>
  );
}

================
File: frontend/src/routes/console/users.tsx
================
import { createFileRoute, Outlet } from "@tanstack/solid-router";

export const Route = createFileRoute("/console/users")({
  component: RouteComponent,
});

function RouteComponent() {
  return (
    <div>
      Hello "/console/users/layout"!
      <Outlet />
    </div>
  );
}

================
File: frontend/src/routes/__root.tsx
================
import type { QueryClient } from "@tanstack/solid-query";
import {
  Link,
  Outlet,
  createRootRouteWithContext,
} from "@tanstack/solid-router";
import type { Api } from "~/api";

export const Route = createRootRouteWithContext<{
  api: Api;
  query: QueryClient;
}>()({
  component: () => (
    <>
      <div class="p-2 flex gap-2">
        <Link to="/hello" class="[&.active]:font-bold">
          Home
        </Link>{" "}
        <Link to="/" class="[&.active]:font-bold">
          Home
        </Link>{" "}
        <Link to="/about" class="[&.active]:font-bold">
          About
        </Link>
        <Link to="/console/users">Users</Link>
      </div>
      <hr />
      <Outlet />
    </>
  ),
  notFoundComponent: () => <div>404 Not Found</div>,
});

================
File: frontend/src/routes/about.tsx
================
import { createFileRoute } from "@tanstack/solid-router";

export const Route = createFileRoute("/about")({
  component: About,
});

function About() {
  return <div class="p-2">Hello from About!</div>;
}

================
File: frontend/src/routes/hello.tsx
================
import { createFileRoute } from '@tanstack/solid-router'

export const Route = createFileRoute('/hello')({
  component: RouteComponent,
})

function RouteComponent() {
  return <div>Hello "/hello"!</div>
}

================
File: frontend/src/routes/index.tsx
================
import { createFileRoute } from "@tanstack/solid-router";

export const Route = createFileRoute("/")({
  component: Index,
});

function Index() {
  return (
    <div class="p-2">
      <h3>Welcome Home!</h3>
    </div>
  );
}

================
File: frontend/src/utils/valibot.ts
================
import * as v from "valibot";
export { v };

================
File: frontend/src/api.ts
================
import { users } from "~/core/users/users.api";
import { v } from "./utils/valibot";

export const API_URL = "http://localhost:8000";

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
export async function get<Schema extends v.BaseSchema<any, any, any>>(
  path: string,
  schema: Schema,
): Promise<v.InferOutput<Schema>> {
  return fetch(`${API_URL}${path}`)
    .then((res) => res.json())
    .then((json) => v.parse(schema, json));
}

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
export async function post<Schema extends v.BaseSchema<any, any, any>>(
  path: string,
  values: unknown,
  schema: Schema,
): Promise<v.InferOutput<Schema>> {
  return fetch(`${API_URL}${path}`, {
    method: "post",
    headers: { "content-type": "application/json" },
    body: JSON.stringify(values),
  })
    .then((res) => res.json())
    .then((json) => v.parse(schema, json));
}

export const api = {
  users,
};

export type Api = typeof api;

================
File: frontend/src/main.tsx
================
import { QueryClient, QueryClientProvider } from "@tanstack/solid-query";
import { RouterProvider, createRouter } from "@tanstack/solid-router";
import { render } from "solid-js/web";
import { api } from "./api";
import { routeTree } from "./routeTree.gen";
import "solid-devtools";

const queryClient = new QueryClient();

const router = createRouter({
  routeTree,
  // Since we're using React Query, we don't want loader calls to ever be stale
  // This will ensure that the loader is always called when the route is preloaded or visited
  defaultPreloadStaleTime: 0,
  scrollRestoration: true,
  context: {
    api,
    query: queryClient,
  },
});

declare module "@tanstack/solid-router" {
  interface Register {
    router: typeof router;
  }
}

const rootElement = document.getElementById("root")!;
if (!rootElement.innerHTML) {
  render(
    () => (
      <QueryClientProvider client={queryClient}>
        <RouterProvider router={router} />
      </QueryClientProvider>
    ),
    rootElement,
  );
}

================
File: frontend/src/routeTree.gen.ts
================
/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols

// This file was automatically generated by TanStack Router.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

// Import Routes

import { Route as rootRoute } from './routes/__root'
import { Route as HelloImport } from './routes/hello'
import { Route as AboutImport } from './routes/about'
import { Route as IndexImport } from './routes/index'
import { Route as ConsoleUsersImport } from './routes/console/users'
import { Route as ConsoleUsersIndexImport } from './routes/console/users/index'
import { Route as ConsoleUsersCreateImport } from './routes/console/users/create'
import { Route as ConsoleUsersUseridImport } from './routes/console/users/$user_id'

// Create/Update Routes

const HelloRoute = HelloImport.update({
  id: '/hello',
  path: '/hello',
  getParentRoute: () => rootRoute,
} as any)

const AboutRoute = AboutImport.update({
  id: '/about',
  path: '/about',
  getParentRoute: () => rootRoute,
} as any)

const IndexRoute = IndexImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => rootRoute,
} as any)

const ConsoleUsersRoute = ConsoleUsersImport.update({
  id: '/console/users',
  path: '/console/users',
  getParentRoute: () => rootRoute,
} as any)

const ConsoleUsersIndexRoute = ConsoleUsersIndexImport.update({
  id: '/',
  path: '/',
  getParentRoute: () => ConsoleUsersRoute,
} as any)

const ConsoleUsersCreateRoute = ConsoleUsersCreateImport.update({
  id: '/create',
  path: '/create',
  getParentRoute: () => ConsoleUsersRoute,
} as any)

const ConsoleUsersUseridRoute = ConsoleUsersUseridImport.update({
  id: '/$user_id',
  path: '/$user_id',
  getParentRoute: () => ConsoleUsersRoute,
} as any)

// Populate the FileRoutesByPath interface

declare module '@tanstack/solid-router' {
  interface FileRoutesByPath {
    '/': {
      id: '/'
      path: '/'
      fullPath: '/'
      preLoaderRoute: typeof IndexImport
      parentRoute: typeof rootRoute
    }
    '/about': {
      id: '/about'
      path: '/about'
      fullPath: '/about'
      preLoaderRoute: typeof AboutImport
      parentRoute: typeof rootRoute
    }
    '/hello': {
      id: '/hello'
      path: '/hello'
      fullPath: '/hello'
      preLoaderRoute: typeof HelloImport
      parentRoute: typeof rootRoute
    }
    '/console/users': {
      id: '/console/users'
      path: '/console/users'
      fullPath: '/console/users'
      preLoaderRoute: typeof ConsoleUsersImport
      parentRoute: typeof rootRoute
    }
    '/console/users/$user_id': {
      id: '/console/users/$user_id'
      path: '/$user_id'
      fullPath: '/console/users/$user_id'
      preLoaderRoute: typeof ConsoleUsersUseridImport
      parentRoute: typeof ConsoleUsersImport
    }
    '/console/users/create': {
      id: '/console/users/create'
      path: '/create'
      fullPath: '/console/users/create'
      preLoaderRoute: typeof ConsoleUsersCreateImport
      parentRoute: typeof ConsoleUsersImport
    }
    '/console/users/': {
      id: '/console/users/'
      path: '/'
      fullPath: '/console/users/'
      preLoaderRoute: typeof ConsoleUsersIndexImport
      parentRoute: typeof ConsoleUsersImport
    }
  }
}

// Create and export the route tree

interface ConsoleUsersRouteChildren {
  ConsoleUsersUseridRoute: typeof ConsoleUsersUseridRoute
  ConsoleUsersCreateRoute: typeof ConsoleUsersCreateRoute
  ConsoleUsersIndexRoute: typeof ConsoleUsersIndexRoute
}

const ConsoleUsersRouteChildren: ConsoleUsersRouteChildren = {
  ConsoleUsersUseridRoute: ConsoleUsersUseridRoute,
  ConsoleUsersCreateRoute: ConsoleUsersCreateRoute,
  ConsoleUsersIndexRoute: ConsoleUsersIndexRoute,
}

const ConsoleUsersRouteWithChildren = ConsoleUsersRoute._addFileChildren(
  ConsoleUsersRouteChildren,
)

export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/about': typeof AboutRoute
  '/hello': typeof HelloRoute
  '/console/users': typeof ConsoleUsersRouteWithChildren
  '/console/users/$user_id': typeof ConsoleUsersUseridRoute
  '/console/users/create': typeof ConsoleUsersCreateRoute
  '/console/users/': typeof ConsoleUsersIndexRoute
}

export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/about': typeof AboutRoute
  '/hello': typeof HelloRoute
  '/console/users/$user_id': typeof ConsoleUsersUseridRoute
  '/console/users/create': typeof ConsoleUsersCreateRoute
  '/console/users': typeof ConsoleUsersIndexRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/': typeof IndexRoute
  '/about': typeof AboutRoute
  '/hello': typeof HelloRoute
  '/console/users': typeof ConsoleUsersRouteWithChildren
  '/console/users/$user_id': typeof ConsoleUsersUseridRoute
  '/console/users/create': typeof ConsoleUsersCreateRoute
  '/console/users/': typeof ConsoleUsersIndexRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/about'
    | '/hello'
    | '/console/users'
    | '/console/users/$user_id'
    | '/console/users/create'
    | '/console/users/'
  fileRoutesByTo: FileRoutesByTo
  to:
    | '/'
    | '/about'
    | '/hello'
    | '/console/users/$user_id'
    | '/console/users/create'
    | '/console/users'
  id:
    | '__root__'
    | '/'
    | '/about'
    | '/hello'
    | '/console/users'
    | '/console/users/$user_id'
    | '/console/users/create'
    | '/console/users/'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  AboutRoute: typeof AboutRoute
  HelloRoute: typeof HelloRoute
  ConsoleUsersRoute: typeof ConsoleUsersRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  AboutRoute: AboutRoute,
  HelloRoute: HelloRoute,
  ConsoleUsersRoute: ConsoleUsersRouteWithChildren,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()

================
File: frontend/.dockerignore
================
node_modules
Dockerfile*
docker-compose*
.dockerignore
.git
.gitignore
README.md
LICENSE
.vscode
Makefile
helm-charts
.env
.editorconfig
.idea
coverage*

================
File: frontend/.gitignore
================
node_modules
dist

================
File: frontend/Dockerfile
================
# use the official Bun image
# see all versions at https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS base
WORKDIR /usr/src/app

# install dependencies into temp directory
# this will cache them and speed up future builds
FROM base AS install
RUN mkdir -p /temp/dev
COPY package.json bun.lock /temp/dev/
RUN cd /temp/dev && bun install --frozen-lockfile

# install with --production (exclude devDependencies)
RUN mkdir -p /temp/prod
COPY package.json bun.lock /temp/prod/
RUN cd /temp/prod && bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# [optional] tests & build
ENV NODE_ENV=production
RUN bun test
RUN bun run build

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/index.ts .
COPY --from=prerelease /usr/src/app/package.json .

# run the app
USER bun
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "run", "index.ts" ]

================
File: frontend/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <link rel="shortcut icon" type="image/ico" href="/src/assets/favicon.ico" />
    <title>Solid App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="/src/main.tsx" type="module"></script>
  </body>
</html>

================
File: frontend/package.json
================
{
  "name": "vite-template-solid",
  "version": "0.0.0",
  "description": "",
  "type": "module",
  "scripts": {
    "start": "vite",
    "dev": "vite",
    "build": "vite build",
    "serve": "vite preview"
  },
  "license": "MIT",
  "devDependencies": {
    "@tanstack/router-plugin": "^1.109.2",
    "solid-devtools": "^0.33.0",
    "typescript": "^5.7.2",
    "vite": "^6.0.0",
    "vite-plugin-solid": "^2.11.1",
    "vite-tsconfig-paths": "^5.1.4"
  },
  "dependencies": {
    "@tanstack/solid-form": "^0.43.2",
    "@tanstack/solid-query": "^5.66.9",
    "@tanstack/solid-router": "^1.110.0",
    "@valibot/i18n": "^1.0.0-rc.0",
    "solid-js": "^1.9.3",
    "valibot": "^1.0.0-rc.1"
  }
}

================
File: frontend/README.md
================
## Usage

Those templates dependencies are maintained via [pnpm](https://pnpm.io) via `pnpm up -Lri`.

This is the reason you see a `pnpm-lock.yaml`. That being said, any package manager will work. This file can be safely be removed once you clone a template.

```bash
$ npm install # or pnpm install or yarn install
```

### Learn more on the [Solid Website](https://solidjs.com) and come chat with us on our [Discord](https://discord.com/invite/solidjs)

## Available Scripts

In the project directory, you can run:

### `npm run dev` or `npm start`

Runs the app in the development mode.<br>
Open [http://localhost:3000](http://localhost:3000) to view it in the browser.

The page will reload if you make edits.<br>

### `npm run build`

Builds the app for production to the `dist` folder.<br>
It correctly bundles Solid in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.<br>
Your app is ready to be deployed!

## Deployment

You can deploy the `dist` folder to any static host provider (netlify, surge, now, etc.)

================
File: frontend/tsconfig.json
================
{
  "compilerOptions": {
    "strict": true,
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "jsx": "preserve",
    "jsxImportSource": "solid-js",
    "types": ["vite/client"],
    "noEmit": true,
    "isolatedModules": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./src/*"]
    }
  }
}

================
File: frontend/vite.config.ts
================
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";
import { defineConfig } from "vite";
import solidPlugin from "vite-plugin-solid";
import viteTsConfigPaths from "vite-tsconfig-paths";
import devtools from "solid-devtools/vite";

export default defineConfig({
  plugins: [
    devtools(),
    TanStackRouterVite({ target: "solid", autoCodeSplitting: true }),
    viteTsConfigPaths({
      projects: ["./tsconfig.json"],
    }),
    solidPlugin(),
  ],
  server: {
    port: 3000,
  },
  build: {
    target: "esnext",
  },
});

================
File: biome.json
================
{
  "$schema": "https://biomejs.dev/schemas/1.9.3/schema.json",
  "vcs": {
    "enabled": false,
    "clientKind": "git",
    "useIgnoreFile": false
  },
  "files": {
    "ignoreUnknown": false,
    "ignore": ["**/routeTree.gen.ts", "node_modules"]
  },
  "formatter": {
    "enabled": true,
    "formatWithErrors": false,
    "ignore": [],
    "attributePosition": "auto",
    "indentStyle": "space",
    "indentWidth": 2,
    "lineWidth": 80,
    "lineEnding": "lf"
  },
  "organizeImports": {
    "enabled": true
  },
  "linter": {
    "enabled": true,
    "rules": {
      "recommended": true,
      "style": {
        "noNonNullAssertion": "off"
      },
      "correctness": {
        "noChildrenProp": "off"
      }
    }
  },
  "javascript": {
    "formatter": {
      "quoteStyle": "double"
    }
  },
  "json": {
    "formatter": {
      "trailingCommas": "none"
    }
  }
}

================
File: compose.yml
================
services:
  postgres:
    image: postgres:17.3
    environment:
      POSTGRES_USER: ${POSTGRES_USER:-postgres}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-postgres}
      POSTGRES_DB: ${POSTGRES_DB:-postgres}
      PGDATA: /var/lib/postgresql/data/pgdata
    volumes:
      - postgres_data:/var/lib/postgresql/data/pgdata
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-postgres}"]
      interval: 10s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  backend:
    build: 
      context: ./backend
      dockerfile: Dockerfile
    environment:
      DATABASE_URL: postgresql://${POSTGRES_USER:-postgres}:${POSTGRES_PASSWORD:-postgres}@postgres:5432/${POSTGRES_DB:-postgres}
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
    restart: unless-stopped

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    depends_on:
      - backend
    restart: unless-stopped

volumes:
  postgres_data:
